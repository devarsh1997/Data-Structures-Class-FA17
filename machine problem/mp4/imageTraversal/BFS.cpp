#include <iostream>#include <iterator>#include <cmath>#include <list>#include <queue>#include "../cs225/PNG.h"#include "../Point.h"#include "ImageTraversal.h"#include "BFS.h"using namespace cs225;using namespace std;/** * Initializes a breadth-first ImageTraversal on a given `png` image, * starting at `start`, and with a given `tolerance`. */BFS::BFS(const PNG & png, const Point & start, double tolerance) {    int i_x = start.x;  int i_y = start.y;  int w = png.width();  int h = png.height();  bool* arr = new bool[w*h];  for (int k=0; k<w*h; k++){    arr[k] = false;  }  tool.push(start);  arr[i_x*h+i_y] = true;  while(!tool.empty()){    int x = tool.front().x;    int y = tool.front().y;    seq.push_back(tool.front());    tool.pop();    if (  x+1 < w      &&  arr[(x+1)*h+y]==false       &&  calculate(*png.getPixel(i_x,i_y), *png.getPixel(x+1,y))<tolerance)    {      tool.push(Point(x+1,y));      arr[(x+1)*h+y] = true;    }    if (  y+1 < h      &&  arr[x*h+y+1]==false       &&  calculate(*png.getPixel(i_x,i_y), *png.getPixel(x,y+1))<tolerance)    {      tool.push(Point(x,y+1));      arr[x*h+y+1] = true;    }    if (  x-1 >= 0      &&  arr[(x-1)*h+y]==false       &&  calculate(*png.getPixel(i_x,i_y), *png.getPixel(x-1,y))<tolerance)    {      tool.push(Point(x-1,y));      arr[(x-1)*h+y] = true;    }    if (  y-1 >= 0      &&  arr[x*h+y-1]==false       &&  calculate(*png.getPixel(i_x,i_y), *png.getPixel(x,y-1))<tolerance)    {      tool.push(Point(x,y-1));      arr[x*h+y-1] = true;    }  }}/** * Returns an iterator for the traversal starting at the first point. */ImageTraversal::Iterator BFS::begin() {  /** @todo [Part 1] */  return ImageTraversal::Iterator(this->seq.begin());}/** * Returns an iterator for the traversal one past the end of the traversal. */ImageTraversal::Iterator BFS::end() {  /** @todo [Part 1] */  return ImageTraversal::Iterator(this->seq.end());}/** * Adds a Point for the traversal to visit at some point in the future. */void BFS::add(const Point & point) {  /** @todo [Part 1] */  this->seq.push_back(point);}/** * Removes and returns the current Point in the traversal. */Point BFS::pop() {  /** @todo [Part 1] */  Point out = this->seq.front();  this->seq.pop_front();  return out;}/** * Returns the current Point in the traversal. */Point BFS::peek() const {  /** @todo [Part 1] */  Point out = this->seq.front();  return out;}/** * Returns true if the traversal is empty. */bool BFS::empty() const {  /** @todo [Part 1] */  return this->seq.empty();}