/** * @file heap.cpp * Implementation of a heap class. */template <class T, class Compare>size_t heap<T, Compare>::root() const{    /// @todo Update to return the index you are choosing to be your root.    return 1;}template <class T, class Compare>size_t heap<T, Compare>::leftChild(size_t currentIdx) const{    /// @todo Update to return the index of the left child.    return currentIdx*2;}template <class T, class Compare>size_t heap<T, Compare>::rightChild(size_t currentIdx) const{    /// @todo Update to return the index of the right child.    return currentIdx*2 + 1;}template <class T, class Compare>size_t heap<T, Compare>::parent(size_t currentIdx) const{    /// @todo Update to return the index of the parent.    return int(currentIdx/2);}template <class T, class Compare>bool heap<T, Compare>::hasAChild(size_t currentIdx) const{    /// @todo Update to return whether the given node has a child    if (currentIdx*2 < _elems.size())        return true;    return false;}template <class T, class Compare>size_t heap<T, Compare>::maxPriorityChild(size_t currentIdx) const{    /// @todo Update to return the index of the child with highest priority    ///   as defined by higherPriority()    if (rightChild(currentIdx) >= _elems.size()){        return leftChild(currentIdx);    }    if (higherPriority(_elems[leftChild(currentIdx)],_elems[rightChild(currentIdx)])){        return leftChild(currentIdx);    }else{        return rightChild(currentIdx);    }}template <class T, class Compare>void heap<T, Compare>::heapifyDown(size_t currentIdx){    /// @todo Implement the heapifyDown algorithm.    if (!hasAChild(currentIdx)){        return;    }    size_t childIdx = maxPriorityChild(currentIdx);    if (higherPriority(_elems[childIdx], _elems[currentIdx])) {        std::swap(_elems[currentIdx], _elems[childIdx]);        heapifyDown(childIdx);    }}template <class T, class Compare>void heap<T, Compare>::heapifyUp(size_t currentIdx){    if (currentIdx == root())        return;    size_t parentIdx = parent(currentIdx);    if (higherPriority(_elems[currentIdx], _elems[parentIdx])) {        std::swap(_elems[currentIdx], _elems[parentIdx]);        heapifyUp(parentIdx);    }}template <class T, class Compare>heap<T, Compare>::heap(){    /// @todo Depending on your implementation, this function may or may    ///   not need modifying    T* sentinal = new T();    _elems.push_back(*sentinal);}// void MinHeap::buildHeap()// {//     std::sort(_elems.begin() + 1, _elems.end());// }template <class T, class Compare>heap<T, Compare>::heap(const std::vector<T>& elems){    /// @todo Construct a heap using the buildHeap algorithm    T* sentinal = new T();    _elems.push_back(*sentinal);    // for (size_t i=0; i<elems.size(); i++){    //     // push(elems[i]);    //     _elems.push_back(elems[i]);    //     // heapifyDown(1);    // }    _elems.insert(_elems.end(), elems.begin(), elems.end());    for (size_t j=_elems.size()-1; j>0; j--){        heapifyDown(j);    }    // _elems.insert(_elems.end(), elems.begin(), elems.end());    // buildHeap();}template <class T, class Compare>T heap<T, Compare>::pop(){    /// @todo Remove, and return, the element with highest priority    // T out = _elems[1];    // _elems.erase(_elems.begin()+1);    // heapifyDown(1);    // return out;    if (_elems.size() > 1) {        T first = _elems[1];        _elems[1] = _elems[_elems.size() - 1];        _elems.pop_back();        heapifyDown(1);        return first;    }    return T();}template <class T, class Compare>T heap<T, Compare>::peek() const{    /// @todo Return, but do not remove, the element with highest priority    return _elems[1];}template <class T, class Compare>void heap<T, Compare>::push(const T& elem){    /// @todo Add elem to the heap    _elems.push_back(elem);    heapifyUp(_elems.size()-1);}template <class T, class Compare>bool heap<T, Compare>::empty() const{    /// @todo Determine if the heap is empty    if (_elems.size() == 1){        return true;    }else{        return false;    }}template <class T, class Compare>void heap<T, Compare>::getElems(std::vector<T> & heaped) const{    for (size_t i = root(); i < _elems.size(); i++) {        heaped.push_back(_elems[i]);    }}template <class T, class Compare>void heap<T, Compare>::print() const{    if (_elems.size() > 1) {        int length = _elems.size();        std::cout << "[";        for (int i = 1; i < length - 1; i++) {            std::cout << _elems[i] << ", ";        }        std::cout << _elems[_elems.size() - 1] << "]" << std::endl;    } else {        std::cout << "[ ]" << std::endl;    }}